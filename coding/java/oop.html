<!DOCTYPE html>

<head>
  <meta charset="UTF-8" lang="ko">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta discription="Java의 기초 문법과 구성에 대해서 설명합니다.">
  <meta keywords="iseohyun, 튜토리얼, Java, 문법, syntax">
  <meta author="iseohyun">

  <!-- 페이지 타이틀 -->
  <title>객체지향: java - iseohyun </title>
  <link rel="shortcut icon" type="image/x-icon" href="/source/icon_seohyun.svg">

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-453XSP5W9M"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-453XSP5W9M');
  </script>

  <!-- 소스코드 스타일 -->
  <link rel="stylesheet" href="/highlight/styles/base16/classic-light.min.css" />
  <script src="/highlight/highlight.min.js"></script>
  <script src="/highlight/highlightjs-line-numbers.js"></script>
  <script>
    hljs.highlightAll();
    hljs.initLineNumbersOnLoad();
  </script>

  <!-- 목차 생성 -->
  <script src="/modules/hd_list.js" defer></script>

  <!-- 코드뷰어 -->
  <script src="/modules/codeview.js"></script>

  <!-- 공통스킨 -->
  <style type="text/css">
    @import url("/style.css");

    del {
      text-decoration-color: inherit;
      color: #BBB;
    }

    .control tr+tr td {
      text-align: left;
      padding: 5px 15px;
      vertical-align: top;
    }

    .control tr+tr td:last-child {
      text-align: left;
      padding: 5px 15px;
      vertical-align: top;
    }
  </style>
</head>

<body>
  <article>
    <div id="title">Java: 객체지향<sub>OOP</sub></div>
    <div id="subtitle"><b>O</b>bject <b>O</b>rient <b>P</b>rogramming</div>

    <p>
      예제코드에서 다운로드는 <a href="setting.html#git%20bash(옵션)" target="_blank">첫 페이지</a>참조<br>
      각각의 실습코드는 <sub>SUB</sub>에 해당하는 폴더를 참조하세요.
    </p>

    <h1>기초문법<sub>a_BasicType</sub></h1>
    <iframe
      src="https://docs.google.com/presentation/d/e/2PACX-1vRRW25vLtrFt_bdDCp22BJRZgcI5-19Vb0FTUCr3S0Fy0w283IjNzY1t6N3PjOx4I2XSokT1L0cHvQU/embed?start=false&amp;loop=false&amp;delayms=3000"
      width="95%" height="500" frameborder="0" allowfullscreen="true"></iframe>
    <h2>클래스 생성<sub>A, B</sub></h2>
    <blockquote>
      <ul>
        <li>
          <pre>
class Class1 { <samp>// 클래스의 선언</samp>
  int field_1; <samp>// 소속변수</samp>
  void method_1() { ... } <samp>// 소속함수</samp>
}</pre>
        </li>
        <li>
          <pre>
Class1 c1; <samp>// 클래스의 생성</samp>
c1 = new Class1();
          </pre>
        </li>
        <li>
          <pre>
c1.field_1 = 1; <samp>// 클래스의 사용(소속변수)</samp>
c1.mathod_1(); <samp>// 클래스의 사용(소속함수)</samp>
          </pre>
        </li>
      </ul>
    </blockquote>
    &nbsp;선언위치는 어디도 될 수 있습니다.<sub>B</sub>
    <pre>
      <code id="inner-class"></code>
    </pre>

    <h3>생성자<sub>C</sub></h3>
    <blockquote>
      <pre>
class Class1 {  
  Class1(int val) { ... } <samp> // 생성자 : 클래스 이름과 같은 이름의 함수(메소드) >> 생성과 함께 수행</samp>
}

Class1 c1 = new Class1(1); <samp> // 생성시 호출</samp>      </pre>
    </blockquote>

    <h3>메모리 공유<sub>D</sub> : Static</h3>
    <blockquote>
      <pre>
class Class1 {  
  static int val = 1;<samp> // 메모리 공유</samp>
}</pre>
    </blockquote>

    <h3>this<sub>E</sub></h3>
    <blockquote>
      <pre>
class Class1 {  
  int val;
  this.val = ... <samp> // 자기 자신을 가리킴</samp>
}</pre>
    </blockquote>

    <h3>클래스 배열<sub>F</sub></h3>
    <blockquote>
      Class1[] arr1 = new Class1[5];
    </blockquote>

    <h2>Interface<sub>G</sub></h2>
    <p>
      '객체지향'코딩은 코딩 속 대상을 인간의 인지와 최대한 흡사하게 구성하여 생산성을 향상시킵니다. 문제는 <u>자바가 다중상속을 지원하지 안되기 때문에</u> 발생합니다.<br>
      &nbsp;예를들어, "먹는다."는 동작은 인간 뿐이 아니라 대부분의 생물군에서 나타날 수 있는 특징입니다. 이를 일일히 구현 할 것인지, 아니면 대표행동을 만들어 놓고 상황봐가며 갈아끼울 것인지
      고민해봐야
      합니다. 여기서 인간의 인지와 비슷하게 코딩하려면 동작에 대한 정의도 필요하다는 것을 알 수 있습니다. 이를 염두하면 어떤 것을 class로 선언 할 지, 어떤 것을 interface로 선언 할 지
      명확해집니다.
    </p>

    <ul>
      <li>static : 메모리 상주형(인스턴스 없이 사용이 가능)</li>
      <li>default : 가장 일반적인 형태</li>
      <li>abstract: 껍데기만 있음(재정의 필요)</li>
    </ul>
    <blockquote>
      <ul>
        <li>
          <pre>
interface Inter1 { <samp>// 클래스의 선언</samp>
  <del>int field_1; <samp>// 일반적으로 사용하지 않음</samp></del>
  void method_1() { ... } <samp>// 소속함수</samp>
}</pre>
        </li>
        <li>
          <pre>
Inter1 c1; <samp>// 클래스의 생성</samp>
c1 = new Inter1();
          </pre>
        </li>
        <li>
          <pre>
c1.field_1 = 1; <samp>// 클래스의 사용(소속변수)</samp>
c1.mathod_1(); <samp>// 클래스의 사용(소속함수)</samp>
          </pre>
        </li>
      </ul>
    </blockquote>

    <h1>상속<sub>b_Extends</sub></h1>
    <h2>기본 문법<sub>A</sub></h2>
    <blockquote>
      class Parent { ... }<br>
      class Child <u>extends</u> Parent { ... }
    </blockquote>
    <h2>오버라이딩<sub>B</sub></h2>
    <ul>
      <li>오버로딩(load:싣다) : 함수명이 같은 함수를 여럿 생성하는 것</li>
      <li>오버라이딩(ride:태우다) : 상속관계에서 기존의 기능을 덮어 씌우는 것</li>
    </ul>
    <blockquote>
      <pre>
class Parent               { String str = "Parent"; }
class Child extends Parent { String str = "Child";  }</pre>
    </blockquote>
    <h2>생성<sub>B2</sub></h2>
    <ul>
      <li>자식은 언제나 부모보다 기능이 같거나 더 많다.</li>
      <li>'기능이 더 적은자'가 '기능이 더 많은 자'를 대체할 수 없다.</li>
    </ul>
    <blockquote>
      Parent pa = new Parent();<br>
      Child ch = new Child();<br>
      Parent pc = new Child();<br>
      Child cp = new Parent(); <samp>// 에러 : 단골 다형성 문제</samp>
    </blockquote>
    <h2>super<sub>C</sub></h2>
    <ul>
      <li>자식은 언제나 부모보다 기능이 같거나 더 많다.</li>
      <li>'기능이 더 적은자'가 '기능이 더 많은 자'를 대체할 수 없다.</li>
    </ul>
    <blockquote>
      super.value = 1;<samp>// 부모의 필드 접근</samp><br>
      super.function();<samp>// 부모의 메소드 호출</samp><br>
      super(); <samp>// 부모의 생성자 호출</samp>
    </blockquote>
    <h2>접근제어자<sub>D</sub></h2>
    <table>
      <tr>
        <td>접근제어자</td>
        <td>기호</td>
        <td>설명</td>
      </tr>
      <tr>
        <td>private</td>
        <td>-</td>
        <td>본인만 접근할 수 있음</td>
      </tr>
      <tr>
        <td>protected</td>
        <td>#</td>
        <td>+ 상속받은 클래스도 접근가능</td>
      </tr>
      <tr>
        <td> </td>
        <td>~</td>
        <td>package protected: 패키지 안에서 자유</td>
      </tr>
      <tr>
        <td>public</td>
        <td>+</td>
        <td>아무나 접근</td>
      </tr>
    </table>
    <h2>추상클래스<sub>E</sub></h2>
    <blockquote>
      <pre>
static abstract class myClass {
  abstract void foo();
}</pre>
    </blockquote>
    <h2>인터페이스 상속<sub>F</sub></h2>
    <blockquote>
      <pre>
interface Inter1 { ... }
interface Inter2 { ... }
class Class1 <u>implements</u> Inter1 { ... }
class Class2 <u>implements</u> Inter1, Inter2 { ... }</pre>
    </blockquote>
    <h2>포함관계 확인<sub>G</sub></h2>
    <blockquote>
      <pre>
static class A { ... }
static class B extends A { ... }
A a = new A();
B b = new B();
if(b instanceof A) { ... } <samp>// true</samp>
if(a instanceof B) { ... } <samp>// false</samp></pre>
    </blockquote>
  </article>
</body>
<script>
  readSrcCode('https://raw.githubusercontent.com/iseohyun/Java-Example/master/BasicCode/OOP/a_Class/B_InnerClass.java', "inner-class", "package comment emptyline");
</script>

</html>